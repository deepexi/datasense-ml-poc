# 统计:
# 门店=able, 在 2000年, 每天的销售额, 以及该天之前三天的累计销售额, 按日期排序
# 输出格式 = able | year | month | day_of_month | 当前销售额 | 前三天销售额
# 注意: 并不是每天都有销售额, 所以日期排序有空缺, 日期并不连续

---
version: v1
resource: model_def
name: store
source:
  source_type: table
  table: store
  datasource: ds_id_ck01
joins:
dimensions:
columns:
  - name: s_store_sk
    data_type: int
  - name: s_store_name
    data_type: string

---
version: v1
resource: model_def
name: date_dim
source:
  source_type: table
  table: date_dim
  datasource: ds_id_ck01
joins:
dimensions:
columns:
  - name: d_date_sk
    data_type: int
  - name: d_year
    data_type: int
  - name: d_moy
    data_type: int
  - name: d_dom
    data_type: int

---
version: v1
resource: model_def
name: store_sales
source:
  source_type: table
  table: store_sales
  datasource: ds_id_ck01
joins:
  - model_name: date_dim
    conditions: [ ss_sold_date_sk=date_dim.d_date_sk ]
  - model_name: store
    conditions: [ ss_store_sk=store.s_store_sk ]
dimensions: [ s_store_name, d_year, d_moy, d_date ]
columns:
  - name: ss_net_paid
    data_type: decimal
  - name: ss_net_profit
    data_type: decimal
  - name: d_year
    expr: date_dim.d_year
  - name: d_moy
    expr: date_dim.d_moy
  - name: s_store_name
    expr: store.s_store_name
  - name: d_dom
    expr: date_dim.d_dom
  - name: d_date
    expr: udf_function(create_date_by_ymd, d_year, d_moy, d_dom)
    # 自定义函数, 格式: udf_function(函数名称不含引号, 0~N个函数参数列表)
    data_type: date

---
version: v1
resource: metric_def
name: sum_ss_net_paid__store_sales
model_name: store_sales
dimensions: [ s_store_name, d_year, d_moy, d_dom, d_date ]
agg: sum(ss_net_paid)

---
version: v1
resource: metrics_query
name: by_day__sum_ss_net_paid__store_sales
metric_names: [ sum_ss_net_paid__store_sales ]
dimensions: [ s_store_name, d_date ]
model_filters: [ d_year=2000, s_store_name='able' ]
metric_filters: [ sum_ss_net_paid__store_sales > 0 ]
# 该窗口表示, 按照日期(天), 累计3天, 从3天前开始, 到1天前结束
# 年内按天 => order by: d_date ====> 推导 partition = dimensions - d_date
# 3天前, 1天前, 推导出 frame_type, start, end
#window:
#  partitions: [ s_store_name, d_year ]
#  # 保留时间无关 s_store_name
#  # 按照 day_of_year进行统计, 保留 year, 一年内连续三天(day_of_year) 并非 月内连续三天
#  order_bys:
#    - name: d_date                      # 连续 "N天"
#  frame_type: range                     # "连续" 三天
#  start:
#    base: n_preceding                   # 3天前开始 包含
#    offset: 3
#  end:
#    base: n_preceding                   # 1天前结束 包含
#    offset: 1

---
version: v1
resource: model_debug
sql: >-
  with t1 as (
    with store_sales as (
      with store_sales as ( select * from store_sales )
      select
        store_sales.ss_net_paid as ss_net_paid,
        store_sales.ss_net_profit as ss_net_profit,
        date_dim.d_year as d_year,
        date_dim.d_moy as d_moy,
        date_dim.d_dom as d_dom,
        store.s_store_name as s_store_name
      from store_sales
      inner join date_dim on store_sales.ss_sold_date_sk=date_dim.d_date_sk
      inner join store on store_sales.ss_store_sk=store.s_store_sk
    )
    select
      store_sales.s_store_name as s_store_name,
      store_sales.d_year as d_year,
      store_sales.d_moy as d_moy,
      store_sales.d_dom as d_dom,
      sum(ss_net_paid) as day_sum_ss_net_paid
    from store_sales
    where
      store_sales.d_year=2000
      and s_store_name='able'
      group by s_store_name, d_year, d_moy, d_dom
  )
  select
    s_store_name,
    d_year,
    d_moy,
    d_dom,
    day_sum_ss_net_paid,
    sum(day_sum_ss_net_paid) over (
      partition by s_store_name
          -- 注意这里创建了虚拟日期
      order by make_date(d_year, d_moy, d_dom) 
          -- 这里用了 interval + 日期, 这是 pg的用法
      range between INTERVAL '3 days' PRECEDING and INTERVAL '1 day' PRECEDING 
    )
  from t1